// 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
// 返回滑动窗口中的最大值。
// 解题思路： 使用一个双端队列存储窗口中值的 索引 ，并且保证双端队列中第一个元素永远是最大值，那么只需要遍历一次 nums，就可以取到每次移动时的最大值。

// 比较当前元素 i 和双端队列第一个元素（索引值），相差 >= k 时队首出列
// 依次比较双端队列的队尾与当前元素 i 对应的值，队尾元素值较小时出列，直至不小于当前元素 i 的值时，或者队列为空，这是为了保证当队头出队时，新的队头依旧是最大值
// 当前元素入队
// 从第 K 次遍历开始，依次把最大值（双端队列的队头）添加到结果 result 中
// 时间复杂度 O(n)     空间复杂度 O(n)
var maxSlidingWindow = function(nums, k) {
  const queue = [];                         //存放单调队列的下标
  const result = [];
  for(let i = 0; i < nums.length; i++){
    if(i - queue[0] >= k) queue.shift();    //在滑动窗口之外的直接从队头删掉
    while(nums[queue[queue.length - 1]] <= nums[i]) queue.pop();   //如果新加进来的数比单调队列中原来的数都要大，则直接弹出队列中的其他数
    queue.push(i);
    if(i >= k - 1) result.push(nums[queue[0]]);  //数组下标从0开始，k=3时 ，下标为0，1，2的数组元素构成一个滑动窗口，所以条件为i>=k-1就可以将答案存入res中
  }
  return result;
};
