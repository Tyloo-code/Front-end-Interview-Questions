// 二进制求和

// 整体思路是将两个字符串较短的用 0 补齐，使得两个字符串长度一致，然后从末尾进行遍历计算，得到最终结果。
// 本题解中大致思路与上述一致，但由于字符串操作原因，不确定最后的结果是否会多出一位进位，所以会有 2 种处理方式：

// 第一种，在进行计算时直接拼接字符串，会得到一个反向字符，需要最后再进行翻转
// 第二种，按照位置给结果字符赋值，最后如果有进位，则在前方进行字符串拼接添加进位
// 时间复杂度：O(n)  空间复杂度O(1)

var addBinary = function(a, b) {
  let ans = '';
  let ca = 0;   //进位标志
  //循环条件以最长二进制数长度为基准，此时短的那个数的位数不足，需要在前端补零
  for(let i = a.length - 1, j = b.length - 1; i >= 0 || j >= 0; i--, j--){  
    let sum = ca;
    sum += i >= 0 ? parseInt(a[i]) : 0;
    sum += j >= 0 ? parseInt(b[j]) : 0;  //如果j<0的话则将其当做0来处理，否则获取其值
    ans += sum % 2;                      //sum%2是在做二进制取模运算，比如sum=2，这时候将sum%2=0放入结果集中
    ca = Math.floor(sum / 2);            //这里是计算进位，比如sum=2，ca = 1，ca表示进位的意思，满2进1
  }
  ans += ca === 1 ? ca : '';             //这一步表示是不是最后还有进位，比如1+1 = 10，10前面的1就是最后留存的进位，需要将其放进去
  return ans.split('').reverse().join('');
}


